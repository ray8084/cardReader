#!/usr/bin/env python3
"""
load_card.py - Reads JSON file from Claude and generates generate2024.py

This script reads the hand data from a JSON file and generates a Python script
that builds hands in memory with parameters for each hand.
"""

import json
import os
import re
from typing import Dict, List, Any

def load_json_file(filename: str) -> Dict[str, Any]:
    """Load and parse JSON file containing hand data."""
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return {}
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON file '{filename}': {e}")
        return {}

def group_hands_by_section(hands: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group hands by their section/family."""
    sections = {}
    for hand in hands:
        section = hand.get('section', hand.get('family', 'Unknown'))
        if section not in sections:
            sections[section] = []
        sections[section].append(hand)
    return sections

def generate_python_script(data: Dict[str, Any], output_filename: str) -> bool:
    """Generate the Python script for building hands."""

    if os.path.exists(output_filename):
        print(f"Refusing to overwrite existing file: {output_filename}")
        print("Please delete the file manually before regenerating.")
        return False

    year = data.get('year', 2024)
    hands = data.get('hands', [])
    sections = group_hands_by_section(hands)
    
    # Get sections in the order they appear in the JSON metadata
    metadata_sections = data.get('metadata', {}).get('sections', [])
    if metadata_sections:
        # Use the order from metadata, filtering out sections that don't exist in data
        section_names = [section for section in metadata_sections if section in sections]
        # Add any remaining sections that weren't in metadata, preserving original order from data
        remaining_sections = [
            section for section in sections.keys() if section not in section_names
        ]
        section_names.extend(remaining_sections)
    else:
        # Fallback to the order the sections appeared in the JSON data
        section_names = list(sections.keys())
    
    script_content = f'''#!/usr/bin/env python3
"""
generate{year}.py - Generated hand builder for {year} card

This file is automatically generated by load_card.py
Contains methods to build hands in memory with parameters for each hand.
"""

from generate import CardGeneratorBase


class Card{year}(CardGeneratorBase):
    """Card builder for {year} with all hand configurations."""

    def __init__(self):
        super().__init__({year})

    def _build_all_hands(self):
        """Build all hands by calling section-specific methods."""
'''
    
    # Add method calls for each section
    for section in section_names:
        method_suffix = re.sub(r'[^0-9A-Za-z]', '', section)
        if not method_suffix:
            method_suffix = "Section"
        method_name = f"generate{method_suffix}"
        script_content += f"        self.{method_name}()\n"
    
    script_content += '''
        # Print summary
        total_tiles = 0
        for hand in self.hand_list:
            total_tiles += len(hand.tile_sets) * 14  # Assuming 14 tiles per hand
            print(f"{hand.id+1} count:{len(hand.tile_sets)} - {hand}")
        print(f"Total tiles: {total_tiles}")
'''
    
    # Generate helper methods for each section
    for section in section_names:
        method_suffix = re.sub(r'[^0-9A-Za-z]', '', section)
        if not method_suffix:
            method_suffix = "Section"
        method_name = f"generate{method_suffix}"
        section_hands = sections[section]
        
        script_content += f'''
    def {method_name}(self):
'''
        
        hand_counter = 0
        for hand in section_hands:
            hand_id = hand.get('id', hand_counter)
            text = hand.get('text', hand.get('hand', ''))
            mask = hand.get('colorMask', hand.get('mask', ''))
            joker_mask = hand.get('jokerMask', '')
            note = hand.get('note', '')
            family = hand.get('family', hand.get('section', section))
            concealed = hand.get('concealed', False)
            points = hand.get('points', hand.get('value', 25))
            
            # Clean up the strings for Python
            text = text.replace('"', '\\"')
            note = note.replace('"', '\\"')
            mask = mask.replace('"', '\\"')
            joker_mask = joker_mask.replace('"', '\\"')
            family = family.replace('"', '\\"')
            
            # Generate mask by replacing only tile characters with 0s, ignore special chars
            mask = ''.join('0' if c not in ' +=' else ' ' for c in text)
            
            # Clean up multiple consecutive spaces
            mask = re.sub(r' +', ' ', mask)
            
            # Generate joker_mask by replacing only tile characters with 1s, ignore special chars
            joker_mask = ''.join('1' if c not in ' +=' else ' ' for c in text)
            
            # Clean up multiple consecutive spaces
            joker_mask = re.sub(r' +', ' ', joker_mask)
            
            # Replace pairs of 1s with 0s since jokers cannot be used in pairs
            # Keep replacing until no more pairs are found
            while ' 11 ' in joker_mask:
                joker_mask = joker_mask.replace(' 11 ', ' 00 ')
            # Handle pairs at the beginning and end
            joker_mask = re.sub(r'^11 ', '00 ', joker_mask)    # pairs at start
            joker_mask = re.sub(r' 11$', ' 00', joker_mask)   # pairs at end
            
            # Replace single 1s with 0s since jokers cannot be used in singles
            joker_mask = re.sub(r'^1 ', '0 ', joker_mask)     # singles at start
            joker_mask = re.sub(r' 1 ', ' 0 ', joker_mask)   # singles in middle
            joker_mask = re.sub(r' 1$', ' 0', joker_mask)     # singles at end
            
            # Analyze tile groups and modify joker mask for non-matching tiles
            # Split by spaces to get individual tile groups (filter out special chars)
            tile_groups = [group for group in text.split() if group not in ['+', '=']]
            joker_mask_parts = joker_mask.split()
            
            for i, group in enumerate(tile_groups):
                if len(group) >= 3:  # Only check groups of 3 or more tiles
                    # Check if all characters in the group are the same
                    if len(set(group)) == 1:  # All tiles are the same (like FFFF, 2222, DDDD)
                        # Keep as 1s - can use jokers for same tiles
                        joker_mask_parts[i] = '1' * len(group)
                    else:  # Different tiles (like 2014, NEWS, 2468)
                        # Replace with 0s - cannot use jokers for different tiles
                        joker_mask_parts[i] = '0' * len(group)
            
            # Reconstruct the joker mask
            joker_mask = ' '.join(joker_mask_parts)
            
            script_content += f'''        p{hand_id} = self.add_hand({hand_id}, "{text}", "{mask}", "{joker_mask}", "{note}", "{family}", {str(concealed).title()}, {points})
        
'''
            hand_counter += 1
    
    script_content += f'''
if __name__ == "__main__":
    card = Card{year}()
    print(f"Generated {{len(card.hand_list)}} hands for {{card.get_year()}}")
'''
    
    # Write the script to file
    with open(output_filename, 'w', encoding='utf-8') as file:
        file.write(script_content)
    
    print(f"Generated {output_filename} with {len(hands)} hands across {len(sections)} sections")
    return True

def main(source_file: str, output_filename: str):
    """Main function to load JSON and generate Python script."""
    if not os.path.exists(source_file):
        print(f"JSON source '{source_file}' not found.")
        return

    print(f"Loading data from: {source_file}")

    data = load_json_file(source_file)
    if not data:
        return
    
    # Generate the Python script
    generated = generate_python_script(data, output_filename)
    if generated:
        print("Generation complete.")

if __name__ == "__main__":
    # COMMENTED OUT - We are now hand-editing generator files to avoid overwrites
    # main("2024_nmjl_card_complete.json", "generate2024.py")
    print("load_card.py is disabled to prevent overwriting hand-edited generator files")
