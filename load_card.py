#!/usr/bin/env python3
"""
load_card.py - Reads JSON file from Claude and generates generate2024.py

This script reads the hand data from a JSON file and generates a Python script
that builds hands in memory with parameters for each hand.
"""

import json
import os
from typing import Dict, List, Any

def load_json_file(filename: str) -> Dict[str, Any]:
    """Load and parse JSON file containing hand data."""
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return {}
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON file '{filename}': {e}")
        return {}

def group_hands_by_section(hands: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group hands by their section/family."""
    sections = {}
    for hand in hands:
        section = hand.get('section', hand.get('family', 'Unknown'))
        if section not in sections:
            sections[section] = []
        sections[section].append(hand)
    return sections

def generate_python_script(data: Dict[str, Any], output_filename: str = "generate2014.py"):
    """Generate the Python script for building hands."""
    
    year = data.get('year', 2024)
    hands = data.get('hands', [])
    sections = group_hands_by_section(hands)
    
    # Get sections in the order they appear in the JSON metadata
    metadata_sections = data.get('metadata', {}).get('sections', [])
    if metadata_sections:
        # Use the order from metadata, filtering out sections that don't exist in data
        section_names = [section for section in metadata_sections if section in sections]
        # Add any remaining sections that weren't in metadata
        remaining_sections = [section for section in sections.keys() if section not in metadata_sections]
        section_names.extend(sorted(remaining_sections))
    else:
        # Fallback to alphabetical sorting if no metadata
        section_names = sorted(sections.keys())
    
    script_content = f'''#!/usr/bin/env python3
"""
generate{year}.py - Generated hand builder for {year} card

This file is automatically generated by load_card.py
Contains methods to build hands in memory with parameters for each hand.
"""

from typing import List, Dict, Any, Optional
from hand import Hand

class Card{year}:
    """Card builder for {year} with all hand configurations."""
    
    def __init__(self):
        self.year = {year}
        self.hand_list: List[Hand] = []
        self._build_all_hands()
    
    def _build_all_hands(self):
        """Build all hands by calling section-specific methods."""
'''
    
    # Add method calls for each section
    for section in section_names:
        method_name = f"generate{section.replace(' ', '').replace('-', '')}"
        script_content += f"        self.{method_name}()\n"
    
    script_content += f'''
        # Print summary
        total_tiles = 0
        for hand in self.hand_list:
            total_tiles += len(hand.tile_sets) * 14  # Assuming 14 tiles per hand
            print(f"{{hand.id+1}} count:{{len(hand.tile_sets)}} - {{hand}}")
        print(f"Total tiles: {{total_tiles}}")
    
    def get_year(self) -> str:
        """Get the year as string."""
        return "{year}"
    
    def add_hand(self, hand_id: int, text: str, mask: str, joker_mask: str, 
                 note: str, family: str, concealed: bool, points: int) -> Hand:
        """Add a new hand to the list and return it."""
        hand = Hand(hand_id, text, mask, joker_mask, note, family, concealed, points)
        self.hand_list.append(hand)
        return hand
'''
    
    # Generate helper methods for each section
    for section in section_names:
        method_name = f"generate{section.replace(' ', '').replace('-', '')}"
        section_hands = sections[section]
        
        script_content += f'''
    def {method_name}(self):
'''
        
        hand_counter = 0
        for hand in section_hands:
            hand_id = hand.get('id', hand_counter)
            text = hand.get('text', hand.get('hand', ''))
            mask = hand.get('colorMask', hand.get('mask', ''))
            joker_mask = hand.get('jokerMask', '')
            note = hand.get('note', '')
            family = hand.get('family', hand.get('section', section))
            concealed = hand.get('concealed', False)
            points = hand.get('points', hand.get('value', 25))
            
            # Clean up the strings for Python
            text = text.replace('"', '\\"')
            note = note.replace('"', '\\"')
            mask = mask.replace('"', '\\"')
            joker_mask = joker_mask.replace('"', '\\"')
            family = family.replace('"', '\\"')
            
            # Generate mask by replacing only tile characters with 0s, ignore special chars
            mask = ''.join('0' if c not in ' +=' else ' ' for c in text)
            
            # Clean up multiple consecutive spaces
            import re
            mask = re.sub(r' +', ' ', mask)
            
            # Generate joker_mask by replacing only tile characters with 1s, ignore special chars
            joker_mask = ''.join('1' if c not in ' +=' else ' ' for c in text)
            
            # Clean up multiple consecutive spaces
            import re
            joker_mask = re.sub(r' +', ' ', joker_mask)
            
            # Replace pairs of 1s with 0s since jokers cannot be used in pairs
            # Keep replacing until no more pairs are found
            while ' 11 ' in joker_mask:
                joker_mask = joker_mask.replace(' 11 ', ' 00 ')
            # Handle pairs at the beginning and end
            joker_mask = re.sub(r'^11 ', '00 ', joker_mask)    # pairs at start
            joker_mask = re.sub(r' 11$', ' 00', joker_mask)   # pairs at end
            
            # Analyze tile groups and modify joker mask for non-matching tiles
            # Split by spaces to get individual tile groups (filter out special chars)
            tile_groups = [group for group in text.split() if group not in ['+', '=']]
            joker_mask_parts = joker_mask.split()
            
            for i, group in enumerate(tile_groups):
                if len(group) >= 3:  # Only check groups of 3 or more tiles
                    # Check if all characters in the group are the same
                    if len(set(group)) == 1:  # All tiles are the same (like FFFF, 2222, DDDD)
                        # Keep as 1s - can use jokers for same tiles
                        joker_mask_parts[i] = '1' * len(group)
                    else:  # Different tiles (like 2014, NEWS, 2468)
                        # Replace with 0s - cannot use jokers for different tiles
                        joker_mask_parts[i] = '0' * len(group)
            
            # Reconstruct the joker mask
            joker_mask = ' '.join(joker_mask_parts)
            
            script_content += f'''        p{hand_id} = self.add_hand({hand_id}, "{text}", "{mask}", "{joker_mask}", "{note}", "{family}", {str(concealed).title()}, {points})
        
'''
            hand_counter += 1
    
    script_content += f'''
if __name__ == "__main__":
    card = Card{year}()
    print(f"Generated {{len(card.hand_list)}} hands for {{card.get_year()}}")
'''
    
    # Write the script to file
    with open(output_filename, 'w', encoding='utf-8') as file:
        file.write(script_content)
    
    print(f"Generated {output_filename} with {len(hands)} hands across {len(sections)} sections")

def main():
    """Main function to load JSON and generate Python script."""
    # Look for JSON files in current directory
    json_files = [f for f in os.listdir('.') if f.endswith('.json') and 'claude' in f.lower()]
    
    if not json_files:
        print("No JSON files with 'claude' in the name found.")
        return
    
    # Use the first found file
    json_file = json_files[0]
    print(f"Loading data from: {json_file}")
    
    data = load_json_file(json_file)
    if not data:
        return
    
    # Generate the Python script
    generate_python_script(data)

if __name__ == "__main__":
    main()
